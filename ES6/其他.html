<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title></title>
	</head>
	<body>
		<script>
			/*
			 * arr.includes    判断数组是否包含某个项
			 * keys/values/entries  数组方法
			 * keys取所有的key    values取所有的value    entries(实体  key与value对应)取出所有的key-value值
			 * for....of   这里循环 是value  只打印纸   下例里面的des不会被打印  可用于数据结构
			 * for....in   这里循环的是key  例如 let list = [1,2,3]; ;list.des = 'aa'  在for in循环中这个des也会被循环出来
			 * forEach  是对for的简化  缺点是无法停止循环
			 * async  awite  与generator yield相似
			 * async可以写成箭头函数  generator不能写成箭头函数
			 * */
			
			let arr = [7,5,3];
			//of 不能用于json  
			for(let i of arr){
				//这里输出的是值
				console.log(i);
			}
			for (let key of arr.keys()){
				console.log(key)
			}
			
			async function show(){
				awite
			}
			//console.log(arr.keys()); 这个不能直接输出

			// 对象属性简写
			let name = 1;
			let obj = {
				name,
				getName(){
					return this.name
				}
			}
			console.log(obj.getName())

			// Symbol()
			let s1 = Symbol()
			let s2 = Symbol()
			console.log(s1 === s2)
			// 这里的s1不等于s2 Symbol出来的都是不一样的
			let sObj = {
				[Symbol('s')]: 1,
				[Symbol('s')]: 2
			}
			console.log(sObj)
			// for in 循环取不到   遍历可以使用Object.getOwnPropertySymbols(sObj).map()
			// map里面要使用[] 而不是点
			// Symbol 无法遍历 可以作为私有对象使用

			// proxy代理  重新定义对象原有的函数  var p = new Proxy(target, handler);
			// 这里的target是被代理对象  handler是对象上的方法
			// let target = {name:1}   
			// handler = {set(){console.log('set')}}
			// p.name = 2  这里就会触发handler里面的set方法
			// 这里使用自己的set方法代替了原有对象的set方法
		</script>
	</body>
</html>
